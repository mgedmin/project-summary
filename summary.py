#!/usr/bin/python3
"""
Generate a summary for all my projects.
"""

import argparse
import datetime
import functools
import glob
import itertools
import json
import linecache
import logging
import math
import os
import pathlib
import subprocess
import sys
import time
import traceback
from configparser import ConfigParser
from functools import cached_property
from typing import (
    Any,
    Callable,
    Collection,
    Iterable,
    Iterator,
    NamedTuple,
    Sequence,
    TextIO,
    Tuple,
    TypeVar,
)
from xml.etree import ElementTree

import arrow
import httpx
import mako.exceptions
import mako.template
import markupsafe
import pypistats
import requests
import requests_cache
import yaml
from requests_cache.backends.sqlite import SQLiteDict


# Yes, there are imports of both httpx and requests.  I use requests because
# requests_cache exists.  I need httpx because pypistats uses httpx and I want
# to catch exceptions.  I would like to switch to httpx everywhere, once I find
# a replacement for requests_cache.


__author__ = 'Marius Gedminas <marius@gedmin.as>'
__version__ = '0.19.0'


log = logging.getLogger('project-summary')


#
# Utilities
#

T = TypeVar('T')


def collect(fn: Callable[..., Iterable[T]]) -> Callable[..., list[T]]:
    return functools.wraps(fn)(lambda *a, **kw: list(fn(*a, **kw)))


def format_cmd(cmd: Sequence[str], cwd: str | None = None) -> str:
    if cwd:
        return f"cd {cwd} && {' '.join(cmd)}"
    else:
        return ' '.join(cmd)


def pipe(*cmd: str, ignore_errors: bool = False, **kwargs) -> str:
    cwd = kwargs.get('cwd')
    log.debug('EXEC %s', format_cmd(cmd, cwd))
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, **kwargs)
    stdout, stderr = p.communicate()
    if p.returncode and not ignore_errors:
        log.warning('%s produced a non-zero exit code: %d',
                    format_cmd(cmd, cwd),
                    p.returncode)
    if stderr and not ignore_errors:
        log.log(logging.WARNING if p.returncode else logging.INFO,
                '%s produced output on stderr:\n%s',
                format_cmd(cmd, cwd),
                stderr.decode('UTF-8', 'replace'))
    return stdout.decode('UTF-8', 'replace')


def to_seconds(value: str) -> int:
    units = {
        1: ('s', 'sec', 'second', 'seconds'),
        60: ('m', 'min', 'minute', 'minutes'),
        3600: ('h', 'hour', 'hours'),
    }
    s = value.replace(' ', '')
    if s.isdigit():
        return int(s)
    for multiplier, suffixes in units.items():
        for suffix in suffixes:
            if s.endswith(suffix):
                prefix = s.removesuffix(suffix)
                if prefix.isdigit():
                    return int(prefix) * multiplier
    raise ValueError(f'bad time: {value}')


#
# Configuration
#

class JenkinsJobConfig(NamedTuple):
    name_template: str = '{name}'
    title: str = ''


class GHAMatrixConfig(NamedTuple):
    title: str
    value: str
    path: str


class Configuration(object):

    _defaults = '''
        [project-summary]
        projects =
        ignore =
        pypi-name-map =
        skip-branches = False
        fetch = False
        pull = False
        gha-workflow-name = build
        gha-workflow-filename = build.yml
        gha-matrix =
        appveyor-account =
        jenkins-url =
        jenkins-jobs = {name}
        python-versions = 3.10 3.11 3.12 3.13 3.14 PyPy
        footer = Generated by <a href="https://github.com/mgedmin/project-summary">project-summary</a>.
    '''.replace('\n        ', '\n').strip()

    def __init__(self, filename: str = 'project-summary.cfg') -> None:
        cp = ConfigParser()
        # https://github.com/python/mypy/issues/5062
        cp.optionxform = lambda s: s.lower().replace('_', '-')  # type: ignore
        cp.read_string(self._defaults, '<defaults>')
        cp.read([filename])
        self._config = cp

    @cached_property
    def projects(self) -> list[str]:
        return self._config.get('project-summary', 'projects').split()

    @cached_property
    def ignore(self) -> list[str]:
        return self._config.get('project-summary', 'ignore').split()

    @cached_property
    def skip_branches(self) -> bool:
        return self._config.getboolean('project-summary', 'skip-branches')

    @cached_property
    def fetch(self) -> bool:
        return self._config.getboolean('project-summary', 'fetch')

    @cached_property
    def pull(self) -> bool:
        return self._config.getboolean('project-summary', 'pull')

    @cached_property
    def gha_workflow_name(self) -> str:
        return self._config.get('project-summary', 'gha-workflow-name')

    @cached_property
    def gha_workflow_filename(self) -> str:
        return self._config.get('project-summary', 'gha-workflow-filename')

    @cached_property
    def gha_matrix(self) -> list[GHAMatrixConfig]:
        return [
            GHAMatrixConfig(*col.split(None, 2))
            for col in self._config.get('project-summary', 'gha-matrix').splitlines()
            if col.strip()
        ] if self.gha_workflow_filename else []

    @cached_property
    def appveyor_account(self) -> str:
        return self._config.get('project-summary', 'appveyor-account')

    @cached_property
    def jenkins_url(self) -> str:
        return self._config.get('project-summary', 'jenkins-url').rstrip('/')

    @cached_property
    def jenkins_jobs(self) -> list[JenkinsJobConfig]:
        return [
            JenkinsJobConfig(*job.split(None, 1))
            for job in self._config.get('project-summary', 'jenkins-jobs').splitlines()
            if job.strip()
        ] if self.jenkins_url else []

    @cached_property
    def footer(self) -> markupsafe.Markup:
        return markupsafe.Markup(
            self._config.get('project-summary', 'footer')
            .replace('{last_update}', arrow.now().format())
        )

    @cached_property
    def pypi_name_map(self) -> dict[str, str]:
        pypi_name_map = {}
        for line in self._config.get('project-summary', 'pypi-name-map').splitlines():
            k, _, v = line.partition(':')
            k = k.strip()
            v = v.strip()
            if k and v:
                pypi_name_map[k] = v
        return pypi_name_map

    @cached_property
    def python_versions(self) -> list[str]:
        return self._config.get('project-summary', 'python-versions').split()


#
# Caching
#

class Cache:

    def get(self, key: str, valid_for: datetime.timedelta, if_missing=lambda: None) -> Any:
        now = datetime.datetime.utcnow()
        value, expires = self._get(key)
        if expires is None or expires < now:
            value = if_missing()
            expires = now + valid_for
            self._set(key, value, expires)
        return value

    def _get(self, key: str) -> Tuple[Any, datetime.datetime | None]:
        return (None, None)

    def _set(self, key: str, value: Any, expires: datetime.datetime) -> None:
        pass


class MemoryCache(Cache):

    def __init__(self) -> None:
        self.cached: dict[str, Any] = {}

    def _get(self, key):
        return self.cached.get(key, (None, None))

    def _set(self, key, value, expires):
        self.cached[key] = (value, expires)


class SQLiteCache(Cache):

    def __init__(self, db_path: str) -> None:
        self.cached = SQLiteDict(db_path, table_name='project_summary_cache', serializer='json')

    def _get(self, key):
        value, expires = self.cached.get(key, (None, None))
        if expires is not None:
            expires = datetime.datetime.fromisoformat(expires)
        return (value, expires)

    def _set(self, key, value, expires):
        self.cached[key] = (value, expires.isoformat())


#
# GitHub API client
#

class GitHubError(Exception):
    pass


class GitHubRateLimitError(GitHubError):
    pass


def log_and_get_url(url: str, session: requests.Session, **kwargs) -> requests.Response:
    if hasattr(session, 'cache'):
        res = session.get(url, only_if_cached=True, **kwargs)  # type: ignore
    else:
        res = None
    if res is not None and res.status_code != 504:  # not cached
        log.debug('HIT %s', url)
    else:
        log.debug('GET %s', url)
        res = session.get(url, **kwargs)
    return res


def github_request(url: str, session: requests.Session) -> requests.Response:
    res = log_and_get_url(url, session)
    if res.status_code == 403 and res.headers.get('X-RateLimit-Remaining') == '0':
        reset_time = int(res.headers['X-RateLimit-Reset'])
        minutes = int(math.ceil((reset_time - time.time()) / 60))
        raise GitHubRateLimitError(
            '{message}\nTry again in {minutes} minutes, at {time}.'.format(
                message=res.json()['message'],
                minutes=minutes,
                time=time.strftime('%H:%M', time.localtime(reset_time)),
            ))
    elif 400 <= res.status_code < 500:
        raise GitHubError(res.json()['message'])
    res.raise_for_status()
    try:
        res.json()
    except ValueError as e:
        raise GitHubError('{e}\nGot: {text!r}\nURL: {url}'.format(
            e=e, text=res.text, url=url))
    return res


def github_request_list(url: str, session: requests.Session, batch_size: int = 100) -> list[dict]:
    res = github_request(f'{url}?per_page={batch_size}', session)
    result = res.json()
    assert isinstance(result, list), result
    for page in itertools.count(2):
        if 'rel="next"' not in res.headers.get('Link', ''):
            break
        res = github_request(f'{url}?per_page={batch_size}&page={page}', session)
        batch = res.json()
        assert isinstance(batch, list), (page, batch)
        result.extend(batch)
    for item in result:
        assert isinstance(item, dict), result
    return result


#
# Data extraction
#

def get_repos(config: Configuration) -> list[str]:
    return sorted(
        dirname
        for path in config.projects
        for dirname in glob.glob(os.path.expanduser(path))
        if os.path.isdir(os.path.join(dirname, '.git'))
    )


def get_repo_url(repo_path: str) -> str | None:
    url = pipe("git", "ls-remote", "--get-url", "origin", cwd=repo_path).strip()
    if url == 'origin':
        return None
    return url


def normalize_github_url(url: str | None) -> str | None:
    if not url:
        return url
    if url.startswith('git://github.com/'):
        url = 'https://github.com/' + url.removeprefix('git://github.com/')
    elif url.startswith('git@github.com:'):
        url = 'https://github.com/' + url.removeprefix('git@github.com:')
    if not url.startswith('https://github.com/'):
        return url
    url = url.removesuffix('.git')
    return url


def get_project_owner(url: str) -> str:
    return url.rpartition('/')[0].rpartition('/')[-1]


def get_project_name(url: str) -> str:
    return url.rpartition('/')[-1]


def get_branch_name(repo_path: str) -> str:
    name = pipe("git", "rev-parse", "--abbrev-ref", "HEAD",
                cwd=repo_path, stderr=subprocess.PIPE).strip()
    if name != 'HEAD':
        return name
    # detached head, oh my
    commit = pipe("git", "rev-parse", "HEAD",
                  cwd=repo_path, stderr=subprocess.PIPE).strip()
    names = set()
    for line in pipe("git", "show-ref", cwd=repo_path, stderr=subprocess.PIPE).splitlines():
        if line.startswith(commit):
            name = line.split()[1]
            name = name.removeprefix('refs/')
            if name.startswith('heads/'):
                name = name.removeprefix('heads/')
            elif name.startswith('remotes/'):
                name = name.removeprefix('remotes/').removeprefix('origin/')
            if name != 'HEAD':
                names.add(name)
    # if several branches point to the same commit, we must've done a
    # fast-forward merge.  if one of those branches is master, we want it,
    # otherwise we might incorrectly skip this repo due to --skip-branches
    if 'main' in names:
        return 'main'
    if 'master' in names:
        return 'master'
    if names:
        return sorted(names)[0]
    # okay, we have a _stale_ detached head, Jenkins must be dropping
    # github notifications again!
    for line in pipe("git", "branch", "-r", "--contains", name, cwd=repo_path, stderr=subprocess.PIPE).splitlines():
        name = line[2:].strip()
        name = name.removeprefix('origin/')
        if not name.startswith('HEAD'):
            return name
    return '(detached)'


def get_last_tag(repo_path: str) -> str:
    return pipe("git", "describe", "--tags", "--abbrev=0",
                cwd=repo_path, stderr=subprocess.PIPE, ignore_errors=True).strip()


def get_date_of_tag(repo_path: str, tag: str) -> str:
    return pipe("git", "log", "-1", "--format=%ai", tag, cwd=repo_path).strip()


def get_pending_commits(repo_path: str, last_tag: str, branch: str = 'master') -> list[str]:
    return pipe("git", "log", "--oneline", f"{last_tag}..origin/{branch}",
                cwd=repo_path).splitlines()


def get_supported_python_versions(repo_path: str) -> list[str]:
    classifiers = pipe(sys.executable, "setup.py", "--classifiers",
                       cwd=repo_path, stderr=subprocess.PIPE).splitlines()
    prefix = 'Programming Language :: Python :: '
    impl_prefix = 'Programming Language :: Python :: Implementation :: '
    cpython = impl_prefix + 'CPython'
    return [
        s.removeprefix(prefix)
        for s in classifiers
        if s.startswith(prefix) and s[len(prefix):len(prefix) + 1].isdigit()
    ] + [
        s.removeprefix(impl_prefix)
        for s in classifiers
        if s.startswith(impl_prefix) and s != cpython
    ]


class Project:

    def __init__(self, working_tree: str, config: Configuration, session: requests.Session, cache: Cache) -> None:
        self.working_tree = working_tree
        self.config = config
        self.session = session
        self.cache = cache

    def __repr__(self):
        return f'<Project {self.name!r}>'

    def _http_get(self, url: str, **kwargs) -> requests.Response:
        response = log_and_get_url(url, self.session, **kwargs)
        response.raise_for_status()
        return response

    def fetch(self) -> None:
        pipe('git', 'fetch', '--prune', cwd=self.working_tree)

    def pull(self) -> None:
        pipe('git', 'pull', '--prune', cwd=self.working_tree)

    def precompute(self, attrs: Sequence[str]) -> None:
        # trigger all the @cached_property decorators
        for attr in attrs:
            getattr(self, attr)

    @cached_property
    def url(self) -> str | None:
        return normalize_github_url(get_repo_url(self.working_tree))

    @cached_property
    def is_on_github(self) -> bool:
        if not self.url:
            return False
        return self.url.startswith('https://github.com/')

    @cached_property
    def uses_github_actions(self) -> bool:
        if not self.is_on_github:
            return False
        # We could glob *.yml and autodetect the gha_workflow_filename.
        return os.path.exists(
            os.path.join(
                self.working_tree,
                '.github',
                'workflows',
                self.config.gha_workflow_filename,
            )
        )

    @cached_property
    def uses_travis(self) -> bool:
        if not self.is_on_github:
            return False
        return os.path.exists(os.path.join(self.working_tree, '.travis.yml'))

    @cached_property
    def uses_coveralls(self) -> bool:
        return self.uses_travis or self.uses_github_actions

    @cached_property
    def uses_appveyor(self) -> bool:
        if not self.is_on_github or not self.config.appveyor_account:
            return False
        return os.path.exists(os.path.join(self.working_tree, 'appveyor.yml'))

    @cached_property
    def uses_jenkins(self) -> bool:
        return bool(self.config.jenkins_url)

    @cached_property
    def branch(self) -> str:
        return get_branch_name(self.working_tree)

    @cached_property
    def last_tag(self) -> str:
        return get_last_tag(self.working_tree)

    @cached_property
    def last_tag_date(self) -> str:
        return get_date_of_tag(self.working_tree, self.last_tag)

    @cached_property
    def pending_commits(self) -> list[str]:
        return get_pending_commits(self.working_tree, self.last_tag, self.branch)

    @cached_property
    def owner(self) -> str | None:
        if self.is_on_github:
            assert self.url is not None
            return get_project_owner(self.url)
        else:
            return None

    @cached_property
    def name(self) -> str:
        if self.url:
            return get_project_name(self.url)
        else:
            return os.path.basename(self.working_tree)

    @cached_property
    def pypi_name(self) -> str:
        # XXX: this is nonsense, I should be extracting the name from setup.py
        return self.config.pypi_name_map.get(self.name, self.name)

    @cached_property
    def pypi_url(self) -> str:
        return f'https://pypi.org/project/{self.pypi_name}/'

    @cached_property
    def jenkins_job(self) -> str:
        if os.path.basename(self.working_tree) == 'workspace':
            return os.path.basename(os.path.dirname(self.working_tree))
        else:
            return os.path.basename(self.working_tree)

    @cached_property
    def compare_url(self) -> str | None:
        if not self.is_on_github:
            return None
        return '{base}/compare/{tag}...{branch}'.format(base=self.url,
                                                        branch=self.branch,
                                                        tag=self.last_tag)

    @cached_property
    def github_actions_image_url(self) -> str | None:
        if not self.uses_github_actions:
            return None
        template = 'https://github.com/{owner}/{name}/actions/workflows/{gha_workflow_filename}/badge.svg?branch={branch}'
        return template.format(
            name=self.name,
            owner=self.owner,
            branch=self.branch,
            gha_workflow_filename=self.config.gha_workflow_filename,
        )

    @cached_property
    def github_actions_url(self) -> str | None:
        if not self.uses_github_actions:
            return None
        return 'https://github.com/{owner}/{name}/actions'.format(
            name=self.name, owner=self.owner
        )

    @cached_property
    def github_actions_status(self) -> str | None:
        if not self.uses_github_actions:
            return None
        assert self.github_actions_image_url is not None
        res = self._http_get(self.github_actions_image_url)
        # We could extract gha_workflow_name from the workflow file itself.
        return self._parse_svg_text(res.text, skip_words={self.config.gha_workflow_name})

    @cached_property
    def github_actions_yaml(self) -> dict | None:
        if not self.uses_github_actions:
            return None
        with pathlib.Path(
            self.working_tree,
            '.github',
            'workflows',
            self.config.gha_workflow_filename,
        ).open() as fp:
            return yaml.safe_load(fp)

    def gha_query(self, path: str) -> list[str]:
        node = self.github_actions_yaml
        if not node:
            return []
        for step in path.split('.'):
            if not isinstance(node, dict) or step not in node:
                return []
            node = node[step]
        if not isinstance(node, list):
            return []
        return list(map(str, node))

    @cached_property
    def travis_image_url(self) -> str | None:
        if not self.uses_travis:
            return None
        # Travis has 20px-high SVG images in the new (flat) style
        template = 'https://api.travis-ci.com/{owner}/{name}.svg?branch={branch}'
        return template.format(name=self.name, owner=self.owner, branch=self.branch)

    @cached_property
    def travis_url(self) -> str | None:
        if not self.uses_travis:
            return None
        return 'https://travis-ci.com/{owner}/{name}'.format(name=self.name,
                                                             owner=self.owner)

    @cached_property
    def travis_status(self) -> str | None:
        if not self.uses_travis:
            return None
        assert self.travis_image_url is not None
        res = self._http_get(self.travis_image_url)
        return self._parse_svg_text(res.text, skip_words={'build'})

    @staticmethod
    def _parse_svg_text(svg_text: str, skip_words: Collection[str] = ()) -> str:
        # let's parse SVG with regexps, what could go wrong???
        try:
            tree = ElementTree.fromstring(svg_text)
        except ElementTree.ParseError:
            return ''
        status = []
        for node in tree.iter('{http://www.w3.org/2000/svg}text'):
            if node.get('fill-opacity'):
                # ignore shadow
                continue
            text = ''.join(map(str.strip, node.itertext()))
            if text and text not in skip_words:
                status.append(text)
        return ' '.join(status)

    @cached_property
    def appveyor_image_url(self) -> str | None:
        if not self.uses_appveyor:
            return None
        template = 'https://ci.appveyor.com/api/projects/status/github/{owner}/{name}?branch={branch}&svg=true'
        return template.format(name=self.name, owner=self.owner, branch=self.branch)

    @cached_property
    def appveyor_url(self) -> str | None:
        if not self.uses_appveyor:
            return None
        return 'https://ci.appveyor.com/project/{account}/{name}/branch/{branch}'.format(
            name=self.name, account=self.config.appveyor_account, branch=self.branch)

    @cached_property
    def appveyor_status(self) -> str | None:
        if not self.uses_appveyor:
            return None
        assert self.appveyor_image_url is not None
        res = self._http_get(self.appveyor_image_url)
        return self._parse_svg_text(res.text, skip_words={'build'})

    @cached_property
    def coveralls_image_url(self) -> str | None:
        if not self.uses_coveralls:
            return None
        # 18px-high PNG
        # template = 'https://coveralls.io/repos/{owner}/{name}/badge.png?branch=master'
        # 20px-high flat SVG
        template = 'https://coveralls.io/repos/{owner}/{name}/badge.svg?branch={branch}'
        # SVG from shields.io (slow)
        # template = 'https://img.shields.io/coveralls/{owner}/{name}.svg?style=flat'
        return template.format(name=self.name, owner=self.owner, branch=self.branch)

    @cached_property
    def coveralls_url(self) -> str | None:
        if not self.uses_coveralls:
            return None
        return 'https://coveralls.io/r/{owner}/{name}?branch={branch}'.format(
            name=self.name, owner=self.owner, branch=self.branch)

    @cached_property
    def coverage_number(self) -> int | None:
        url = self.coveralls_image_url
        if not url:
            return None
        res = self._http_get(url, allow_redirects=False)
        location = res.headers.get('Location')
        if res.status_code != 302 or not location:
            return None
        PREFIX = 'https://s3.amazonaws.com/assets.coveralls.io/badges/coveralls_'
        SUFFIX = '.svg'
        if location.startswith(PREFIX) and location.endswith(SUFFIX):
            coverage = location.removeprefix(PREFIX).removesuffix(SUFFIX)
            if coverage.isdigit():  # could be 'unknown'
                return int(coverage)
        return None

    def coverage(self, format: str = '{}', unknown: str = '-1') -> str:
        if self.coverage_number is None:
            return unknown
        else:
            return format.format(self.coverage_number)

    def get_jenkins_image_url(self, job_config: JenkinsJobConfig = JenkinsJobConfig()) -> str | None:
        if not self.uses_jenkins:
            return None
        return '{base}/job/{name}/badge/icon'.format(
            base=self.config.jenkins_url,
            name=job_config.name_template.format(name=self.jenkins_job),
        )

    def get_jenkins_url(self, job_config: JenkinsJobConfig = JenkinsJobConfig()) -> str | None:
        if not self.uses_jenkins:
            return None
        return '{base}/job/{name}/'.format(
            base=self.config.jenkins_url,
            name=job_config.name_template.format(name=self.jenkins_job),
        )

    def get_jenkins_status(self, job_config: JenkinsJobConfig = JenkinsJobConfig()) -> str | None:
        if not self.uses_jenkins:
            return None
        url = self.get_jenkins_image_url(job_config)
        assert url is not None
        res = self._http_get(url)
        return self._parse_svg_text(res.text, skip_words={'build'})

    @cached_property
    def python_versions(self) -> list[str]:
        return get_supported_python_versions(self.working_tree)

    @cached_property
    def github_issues_and_pulls(self) -> list[dict]:
        if not self.is_on_github:
            return []
        url = 'https://api.github.com/repos/{owner}/{name}/issues'.format(
            owner=self.owner, name=self.name)
        return github_request_list(url, self.session)

    @cached_property
    def github_issues(self) -> list[dict]:
        return [issue for issue in self.github_issues_and_pulls
                if 'pull_request' not in issue]

    @cached_property
    def github_pulls(self) -> list[dict]:
        return [issue for issue in self.github_issues_and_pulls
                if 'pull_request' in issue]

    @cached_property
    def open_issues_count(self) -> int:
        return len(self.github_issues)

    @cached_property
    def unlabeled_open_issues_count(self) -> int:
        return sum(1 for issue in self.github_issues if not issue['labels'])

    @cached_property
    def issues_url(self) -> str | None:
        if not self.is_on_github:
            return None
        return f'{self.url}/issues'

    @cached_property
    def open_pulls_count(self) -> int:
        return len(self.github_pulls)

    @cached_property
    def unlabeled_open_pulls_count(self) -> int:
        return sum(1 for issue in self.github_pulls if not issue['labels'])

    @cached_property
    def pulls_url(self) -> str | None:
        if not self.is_on_github:
            return None
        return f'{self.url}/pulls'

    @cached_property
    def pypistats_url(self) -> str:
        return f'https://pypistats.org/packages/{self.pypi_name}'

    @cached_property
    def downloads(self) -> int | None:
        # https://pypistats.org/api/#etiquette:
        # - the data is updated once daily and should be cached
        # - there's IP-based rate limiting
        try:
            data = self.cache.get(
                self.pypistats_url,
                valid_for=datetime.timedelta(days=1),
                if_missing=lambda:
                    json.loads(pypistats.recent(self.pypi_name, format='json'))
            )
        except httpx.HTTPStatusError as e:
            log.warning('%s error for %s', e.response.status_code, self.pypistats_url)
            return None
        except httpx.HTTPError as e:
            log.warning(e)
            return None
        else:
            return data['data']['last_month']


@collect
def get_projects(config: Configuration, session: requests.Session, cache: Cache) -> Iterable[Project]:
    return _filter_projects((
        Project(path, config, session, cache) for path in get_repos(config)
    ), config)


def _filter_projects(projects: Iterable[Project], config: Configuration) -> Iterable[Project]:
    for p in projects:
        if p.name in config.ignore:
            continue
        if config.skip_branches and p.branch not in ('main', 'master'):
            continue
        if config.fetch:
            p.fetch()
        if config.pull:
            p.pull()
        if p.last_tag:
            yield p


#
# Templating
#

Markup = str | markupsafe.Markup


def mako_error_handler(context, error) -> None:
    """Decorate tracebacks when Mako errors happen.

    Evil hack: walk the traceback frames, find compiled Mako templates,
    stuff their (transformed) source into linecache.cache.

    https://gist.github.com/mgedmin/4269249
    """
    rich_tb = mako.exceptions.RichTraceback()
    rich_iter = iter(rich_tb.traceback)
    tb = sys.exc_info()[-1]
    source: dict[str, list[str]] = {}
    annotated = set()
    while tb is not None:
        cur_rich = next(rich_iter)
        f = tb.tb_frame
        co = f.f_code
        filename = co.co_filename
        lineno = tb.tb_lineno
        if filename.startswith('memory:'):
            lines = source.get(filename)
            if lines is None:
                info = mako.template._get_module_info(filename)
                lines = source[filename] = info.module_source.splitlines(True)
                linecache.cache[filename] = (None, None, lines, filename)  # type: ignore
            if (filename, lineno) not in annotated:
                annotated.add((filename, lineno))
                extra = '    # {0} line {1} in {2}:\n    # {3}'.format(*cur_rich)
                lines[lineno - 1] += extra
        tb = tb.tb_next
    # Don't return False -- that will lose the actual Mako frame.  Instead
    # re-raise.
    raise


def Template(*args, **kw) -> mako.template.Template:
    kw.setdefault('default_filters', ['h'])
    return mako.template.Template(error_handler=mako_error_handler,
                                  strict_undefined=True,
                                  *args, **kw)


def html(tag: str | None, body: str | None = '', **kw: str | None) -> markupsafe.Markup:
    if body is None:
        body = ''
    if not tag:
        return markupsafe.escape(body)
    attrs = ''.join(f''' {name.rstrip('_')}="{markupsafe.escape(value)}"'''
                    for name, value in kw.items() if value is not None)
    if tag in ('img', 'link', 'br', 'hr', 'meta', 'col'):
        assert not body
        return markupsafe.Markup(f'<{tag}{attrs}>')
    return markupsafe.Markup(f'<{tag}{attrs}>{markupsafe.escape(body)}</{tag}>')


def css_class(*args: str | None) -> str | None:
    return ' '.join(c for c in args if c) or None


#
# Report generation
#


PYTHON_EOL_DATE = {
    # Source: https://devguide.python.org/versions/
    '2.7': '2020-01-01',
    '3.6': '2021-12-23',
    '3.7': '2023-06-27',
    '3.8': '2024-10-07',
    '3.9': '2025-10-01',   # approximate
    '3.10': '2026-10-01',  # approximate
    '3.11': '2027-10-01',  # approximate
    '3.12': '2028-10-01',  # approximate
    '3.13': '2029-10-01',  # approximate
    '3.14': '2030-10-01',  # approximate
}


class Pages:

    def __init__(self, pages) -> None:
        self.pages = pages

    def __iter__(self) -> Iterator['Page']:
        return iter(self.pages)

    def stylesheet(self, variant: str | None = None) -> markupsafe.Markup:
        seen = set()
        styles = []
        for page in self.pages:
            for column in page.columns:
                for rules in column.stylesheet_rules(page, variant):
                    if rules and rules not in seen:
                        seen.add(rules)
                        styles.append(rules)
        return markupsafe.Markup('').join(styles)


class Page:

    def __init__(self, title: str, columns: list['Column']) -> None:
        self.title = title
        self.name = '-'.join(title.lower().split())
        self.columns = columns

    def js_text_extractors(self) -> Markup:
        cols = [(idx, col) for idx, col in enumerate(self.columns)
                if col.js_sort_rule]
        return '\n            '.join(
            col.js_text_extractor(idx, idx == cols[-1][0])
            for idx, col in cols
        )

    def js_render_header(self, comma: str = ',') -> Markup:
        cols = [idx for idx, col in enumerate(self.columns)
                if col.align == 'right']
        if not cols:
            return ''
        for pivot, col in enumerate(self.columns):
            if cols == list(range(pivot, len(self.columns))):
                expr = f'idx >= {pivot}'
                break
        else:
            expr = ' || '.join(f'idx == {n}' for n in cols)
        return markupsafe.Markup(JS(f'''
          onRenderHeader: function(idx, config, table) {{
            // move the sort indicator to the left for right-aligned columns
            if ({expr}) {{
              var $this = $(this);
              $this.find('div').prepend($this.find('i'));
            }}
          }}{comma}
        '''))


def strip_leading_newline_and_trailing_spaces(rules: str) -> str:
    return rules.lstrip('\n').rstrip(' ')


JS = strip_leading_newline_and_trailing_spaces


def CSS(rules: str) -> list[str]:
    return [strip_leading_newline_and_trailing_spaces(rules)]


class Column:
    title: str | None = None
    title_tooltip: str | None = None
    title_narrow: str | None = None
    css_class: str | None = None  # used as a css selector
    extra_css_class: str | None = None  # not used as a css selector
    css_rules = CSS('''
    % if column.align:
      #${page.name} th.${css_class},
      #${page.name} td.${css_class} { text-align: ${column.align}; }
    % endif
    ''')
    css_rules_narrow = CSS('''
        #${page.name} td${discrim}:before { content: "${column.title_narrow or column.title|h}: "; }
    ''') + CSS('''
    % if column.align:
        #${page.name} td${discrim} { text-align: left; }
    % endif
    ''')
    js_sort_rule: Tuple[str, str] | None = None

    def __init__(
        self,
        title: str | None = None,
        *,
        css_class: str | None = None,
        width: str | None = None,
        align: str | None = None,
    ) -> None:
        if title is not None:
            self.title = title
        if css_class is not None:
            self.css_class = css_class
        self.width = width
        self.align = align

    def js_text_extractor(self, index: int, last: bool) -> Markup:
        if not self.js_sort_rule:
            return ''
        sorter, comment = self.js_sort_rule
        if not last:
            sorter += ","
        return f'{index}: {sorter:<20} // {comment}'

    def stylesheet_rules(self, page: Page, variant: str | None = None) -> list[Markup]:
        if variant:
            rules = getattr(self, f'css_rules_{variant}')
        else:
            rules = self.css_rules
        if not rules:
            return []
        unique_class = all(col.css_class != self.css_class
                           for col in page.columns
                           if col != self)
        if self.css_class is None or not unique_class:
            discrim = f":nth-child({page.columns.index(self) + 1})"
        else:
            discrim = f".{self.css_class}"
        # XXX: is it a good idea to put 'n' in default_filters here?
        # what would break if I removed it?  I should do that once I have 100%
        # test coverage.
        return [
            markupsafe.Markup(css)
            for css in [
                Template(rule, default_filters=['str', 'n']).render_unicode(
                    page=page,
                    column=self,
                    css_class=self.css_class,
                    discrim=discrim,
                )
                for rule in rules
            ] if css
        ]

    def col(self) -> markupsafe.Markup:
        return html('col', width=self.width)

    def th(self) -> markupsafe.Markup:
        return html(
            'th',
            self.title,
            class_=css_class(self.css_class, self.extra_css_class),
            title=self.title_tooltip,
        )

    def td(self, project: Project) -> markupsafe.Markup:
        return html(
            'td',
            self.inner_html(project),
            class_=css_class(self.css_class, self.extra_css_class),
            title=self.tooltip(project),
            **{
                f'data-{item}': value
                for item, value in self.get_data(project).items()
            },
        )

    def tooltip(self, project: Project) -> str | None:
        return None

    def get_data(self, project: Project) -> dict[str, str]:
        return {}

    def inner_html(self, project: Project) -> Markup:
        raise NotImplementedError(f"{type(self).__name__} should implement .inner_html()")


class NameColumn(Column):
    title = 'Name'
    css_class = 'name'
    css_rules_narrow = CSS('''
    % if column.align:
        #${page.name} td.${css_class} { text-align: left; }
    % endif
    ''')

    def inner_html(self, project: Project) -> Markup:
        return html('a', project.name, href=project.url) + (
            f' {project.branch}' if project.branch not in ('main', 'master')
            else ''
        )


class VersionColumn(Column):
    title = 'Last release'
    css_class = 'version'

    def inner_html(self, project: Project) -> Markup:
        return html('a', project.last_tag, href=project.pypi_url)


class DateColumn(Column):
    title = 'Date'
    css_class = 'date'
    js_sort_rule = ('sortTitleAttribute', 'ISO-8601 date in title')

    def tooltip(self, project: Project) -> str:
        return project.last_tag_date

    def inner_html(self, project: Project) -> Markup:
        return nice_date(project.last_tag_date)


class ChangesColumn(Column):
    title = 'Pending changes'
    css_class = 'changes'

    def inner_html(self, project: Project) -> Markup:
        return html('a', pluralize(len(project.pending_commits), 'commits'),
                    href=project.compare_url)


class StatusTuple(NamedTuple):
    url: str | None
    image_url: str | None
    status: str | None


class StatusColumn(Column):
    css_class = 'status'
    css_rules = Column.css_rules + CSS('''
    % if column is not page.columns[-1]:
      #${page.name} th.${css_class},
      #${page.name} td.${css_class} { padding-right: 0; }
    % endif
    ''')
    js_sort_rule = ('sortAltText', 'build status in alt text')

    def inner_html(self, project: Project) -> Markup:
        url, image_url, status = self.get_status(project)
        if not url:
            return '-'
        return html(
            'a',
            html('img', src=image_url, alt=status, height='20'),
            href=url,
        )

    def get_status(self, project: Project) -> StatusTuple:
        raise NotImplementedError


class BuildStatusColumn(StatusColumn):
    title = 'Build status'
    title_narrow = 'Build status'

    def get_status(self, project: Project) -> StatusTuple:
        if project.uses_github_actions:
            return StatusTuple(
                project.github_actions_url,
                project.github_actions_image_url,
                project.github_actions_status,
            )
        else:
            return StatusTuple(
                project.travis_url,
                project.travis_image_url,
                project.travis_status,
            )


class GitHubActionsColumn(StatusColumn):
    title = 'GitHub Actions'
    title_narrow = 'GHA status'

    def get_status(self, project: Project) -> StatusTuple:
        return StatusTuple(
            project.github_actions_url,
            project.github_actions_image_url,
            project.github_actions_status,
        )


class GHAMatrixColumn(StatusColumn):

    def __init__(self, matrix: GHAMatrixConfig, **kwargs) -> None:
        super().__init__(title=matrix.title, **kwargs)
        self.title_narrow = matrix.title
        self.matrix = matrix

    def inner_html(self, project: Project) -> Markup:
        yes = self.matrix.value in project.gha_query(self.matrix.path)
        return html('span', class_='yes' if yes else 'no',
                    body='+' if yes else '\u2212')


class TravisColumn(StatusColumn):
    title = 'Travis CI'
    title_narrow = 'Travis CI status'

    def get_status(self, project: Project) -> StatusTuple:
        return StatusTuple(
            project.travis_url,
            project.travis_image_url,
            project.travis_status,
        )


class JenkinsColumn(StatusColumn):
    js_sort_rule = ('sortAltText', 'jenkins build status in alt text')

    def __init__(self, job: JenkinsJobConfig, **kwargs) -> None:
        super().__init__(title=f"Jenkins {job.title}", **kwargs)
        self.title_narrow = f"Jenkins {job.title} status"
        self.job = job

    def get_status(self, project: Project) -> StatusTuple:
        return StatusTuple(
            project.get_jenkins_url(self.job),
            project.get_jenkins_image_url(self.job),
            project.get_jenkins_status(self.job),
        )


class AppveyorColumn(StatusColumn):
    title = 'Appveyor'
    title_narrow = 'Appveyor status'
    js_sort_rule = ('sortAltText', 'appveyor build status in alt text')

    def get_status(self, project: Project) -> StatusTuple:
        return StatusTuple(
            project.appveyor_url,
            project.appveyor_image_url,
            project.appveyor_status,
        )


class CoverallsColumn(StatusColumn):
    title = 'Coveralls'
    title_narrow = 'Coveralls status'
    js_sort_rule = ('sortCoverage', 'coverage percentage in data attribute')

    def get_data(self, project: Project) -> dict[str, str]:
        return dict(
            coverage=project.coverage(),
        )

    def get_status(self, project: Project) -> StatusTuple:
        return StatusTuple(
            project.coveralls_url,
            project.coveralls_image_url,
            project.coverage('{}%', 'unknown'),
        )


class DataColumn(Column):
    # This is a bad class name.  TwoCountsColumn?  NewAndTotalColumn?

    css_rules = Column.css_rules + CSS('''
      #${page.name} span.new { font-weight: bold; }
      #${page.name} span.none { color: #999; }
    ''')

    def inner_html(self, project: Project) -> Markup:
        new, total = self.get_counts(project)
        return html(
            'a',
            href=self.get_url(project),
            title=f'{new} new, {total} total',
            body=markupsafe.Markup(' ').join((
                html('span', f'{new}', class_='new' if new else 'none'),
                html(None if total else 'span', f'({total})', class_='none'),
            )),
        )

    def get_data(self, project: Project) -> dict[str, str]:
        new, total = self.get_counts(project)
        return dict(
            new=str(new),
            total=str(total),
        )

    def get_url(self, project: Project) -> str | None:
        raise NotImplementedError

    def get_counts(self, project: Project) -> Tuple[int, int]:
        raise NotImplementedError


class IssuesColumn(DataColumn):
    title = 'Issues'
    title_narrow = 'GitHub issues'
    css_class = 'issues'
    js_sort_rule = ('sortIssues', 'issue counts in data attributes')

    def get_url(self, project: Project) -> str | None:
        return project.issues_url

    def get_counts(self, project: Project) -> Tuple[int, int]:
        return (
            project.unlabeled_open_issues_count,
            project.open_issues_count,
        )


class PullsColumn(DataColumn):
    title = 'PRs'
    title_narrow = 'GitHub pull requests'
    css_class = 'pulls'
    js_sort_rule = ('sortIssues', 'PR counts in data attributes')

    def get_url(self, project: Project) -> str | None:
        return project.pulls_url

    def get_counts(self, project: Project) -> Tuple[int, int]:
        return (
            project.unlabeled_open_pulls_count,
            project.open_pulls_count,
        )


class PythonSupportColumn(Column):
    css_rules = Column.css_rules + CSS('''
      #${page.name} th.eol,
      #${page.name} td.eol { background-color: #f5f5f5; }
    ''')

    def __init__(self, ver: str, **kwargs) -> None:
        super().__init__(title=ver, **kwargs)
        self.title_narrow = ver if ver.startswith('PyPy') else f"Python {ver}"
        self.ver = ver
        self.is_eol = False
        if ver in PYTHON_EOL_DATE:
            self.title_tooltip = f"Supported until {PYTHON_EOL_DATE[ver]}"
            self.is_eol = str(datetime.date.today()) >= PYTHON_EOL_DATE[ver]
        if self.is_eol:
            self.extra_css_class = 'eol'

    def inner_html(self, project: Project) -> Markup:
        supported = self.ver in project.python_versions
        return html('span', class_='yes' if supported else 'no',
                    body='+' if supported else '\u2212')


class PypiStatsColumn(Column):
    title = 'Downloads'
    title_tooltip = 'PyPI downloads last month'
    title_narrow = 'Downloads last month'
    css_class = 'downloads'

    def inner_html(self, project: Project) -> Markup:
        return html('a', href=project.pypistats_url,
                    body=f'{project.downloads:,}' if project.downloads is not None else '-')


def get_report_pages(config: Configuration) -> Pages:
    return Pages([
        Page('Release status', [
            NameColumn(),
            VersionColumn(),
            DateColumn(align='right'),
            ChangesColumn(align='right'),
            BuildStatusColumn(align='right'),
        ]),
        Page('Maintenance', [
            NameColumn(width='15%'),
            GitHubActionsColumn(width='15%'),
            *(GHAMatrixColumn(mc, width='15%') for mc in config.gha_matrix),
            *(JenkinsColumn(job, width='15%') for job in config.jenkins_jobs),
            *(AppveyorColumn(width="15%") for a in [config.appveyor_account] if a),
            CoverallsColumn(width="15%"),
            PypiStatsColumn(width='5%', align='right'),
            IssuesColumn(width="5%", align='right'),
            PullsColumn(width="5%", align='right'),
        ]),
        Page('Python versions', [
            NameColumn(),
            *(PythonSupportColumn(ver) for ver in config.python_versions),
            CoverallsColumn('Test coverage'),
        ]),
    ])


template = Template('''\
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Projects</title>

    <link rel="stylesheet" href="assets/css/bootstrap.min.css">

    <style type="text/css">
      th { white-space: nowrap; }
      td > a > img { position: relative; top: -1px; }
      .tablesorter-icon { color: #ddd; }
      .tablesorter-header { cursor: default; }
      .invisible { visibility: hidden; }
      span.no,
      span.yes {
        padding: 2px 4px 3px 4px;
        font-family: DejaVu Sans, Verdana, Geneva, sans-serif;
        font-size: 11px;
        position: relative;
        bottom: 2px;
      }
      span.no {
        color: #888;
      }
      span.yes {
        color: #fff;
        background-color: #4c1;
        text-shadow: 0px 1px 0px rgba(1, 1, 1, 0.3);
        border-radius: 4px;
      }
      ${report_pages.stylesheet().strip()}
      footer { padding-top: 16px; padding-bottom: 16px; text-align: center; color: #999; }

      @media (max-width: 992px) {
        .container { width: auto; }
      }
      @media (max-width: 600px) {
        .page-header {
          display: flex;
          flex-flow: column;
        }
        .page-header .pull-right {
          float: none !important;
          display: box;
          margin: 0 auto;
        }
      }
      @media (max-width: 769px) {
        .page-header { margin-bottom: 0; }
        table, tbody, th, td, tr { display: block; }
        thead { display: none; }
        tr:first-child > td:first-child {
          border-top: none !important;
        }
        td:not(:first-child) {
          padding: 0px 2em 8px 2em !important;
          border-top: none !important;
        }
        ${report_pages.stylesheet('narrow').strip()}
        td:before { display: inline-block; width: 50%; }
      }
    </style>

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body role="document">
    <div class="container">

      <div class="page-header">
        <div class="btn-group pull-right" role="menu">
% for idx, page in enumerate(report_pages):
          <a class="btn ${'btn-primary' if idx == 0 else 'btn-default'}" data-toggle="tab" href="#${page.name}">${page.title}</a>
% endfor
        </div>
        <h1>Projects</h1>
      </div>

      <div class="tab-content">

% for idx, page in enumerate(report_pages):
        <div class="tab-pane${' active' if idx == 0 else ''}" id="${page.name}">
          <table class="table table-hover">
%     if any(column.width for column in page.columns):
            <colgroup>
%         for column in page.columns:
              ${column.col()}
%         endfor
            </colgroup>
%     endif
            <thead>
              <tr>
%     for column in page.columns:
                ${column.th()}
%     endfor
              </tr>
            </thead>
            <tbody>
%     for project in projects:
              <tr>
%         for column in page.columns:
                ${column.td(project)}
%         endfor
              </tr>
%     endfor
            </tbody>
          </table>
        </div>

% endfor
      </div>
    </div>
    <footer>
      <div class="container">
${config.footer.strip()}
      </div>
    </footer>
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery.tablesorter.min.js"></script>
    <script src="assets/js/jquery.tablesorter.widgets.min.js"></script>
    <script src="assets/js/bootstrap.min.js"></script>
    <script>
      $(function() {
        $.extend($.tablesorter.themes.bootstrap, {
            table        : '',
            caption      : '',
            header       : '',
            footerRow    : '',
            footerCells  : '',
            sortNone     : '',
            sortAsc      : '',
            sortDesc     : '',
            active       : '',
            hover        : 'active',
            icons        : '',
            iconSortNone : 'glyphicon glyphicon-sort invisible',
            iconSortAsc  : 'glyphicon glyphicon-sort-by-attributes',
            iconSortDesc : 'glyphicon glyphicon-sort-by-attributes-alt',
            filterRow    : '',
            footerRow    : '',
            footerCells  : '',
            even         : '',
            odd          : ''
          });
        var sortTitleAttribute = function(node, table, cellIndex) {
          return $(node).attr('title');
        };
        var sortAltText = function(node, table, cellIndex) {
          return $(node).attr('alt');
        };
        var sortCoverage = function(node, table, cellIndex) {
          return $(node).attr('data-coverage');
        };
        var sortIssues = function(node, table, cellIndex) {
          /* note this can't start with a digit or tablesorter will discard the 2nd sort key */
          return 'new ' + $(node).attr('data-new') + ' old ' + $(node).attr('data-total');
        };
% for page in report_pages:
        $("#${page.name} table").tablesorter({
          theme: "bootstrap",
          widgets: ['uitheme'],
          widthFixed: true,
          headerTemplate: ' {content} {icon}',
${page.js_render_header()}\\
          sortList: [[0, 0]],
          textExtraction: {
            ${page.js_text_extractors()}
          }
        });
% endfor
        var dont_recurse = false;
        $('a[data-toggle="tab"]').on('shown.bs.tab', function(e) {
          $(e.target).siblings('.btn-primary').removeClass('btn-primary').addClass('btn-default');
          $(e.target).removeClass('btn-default').addClass('btn-primary');
          if (!dont_recurse) {
            dont_recurse = true;
            if (history.pushState) {
              history.pushState(null, null, '#'+$(e.target).attr('href').substr(1));
            } else {
              location.hash = '#'+$(e.target).attr('href').substr(1);
            }
            dont_recurse = false;
          }
        });
        if (location.hash !== '') {
          dont_recurse = true;
          $('a[href="' + location.hash + '"]').tab('show');
          dont_recurse = false;
        }
        $(window).bind('hashchange', function() {
          if (!dont_recurse) {
            dont_recurse = true;
            $('a[href="' + (location.hash || '#${report_pages.pages[0].name}') + '"]').tab('show');
            dont_recurse = false;
          }
        });
      });
    </script>
  </body>
</html>
''')


def nice_date(date_string: str) -> str:
    # specify format because https://github.com/crsmithdev/arrow/issues/82
    return arrow.get(date_string, 'YYYY-MM-DD HH:mm:ss Z').humanize()


def pluralize(number: int, noun: str) -> str:
    if number == 1:
        assert noun.endswith('s')
        noun = noun[:-1]  # poor Englishman's i18n
    return f'{number} {noun}'


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Summarize release status of several projects")
    parser.add_argument('--version', action='version',
                        version="%(prog)s version " + __version__)
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help='be more verbose (can be repeated)')
    parser.add_argument('--skip-branches', action='store_true',
                        help="ignore checkouts that aren't of the main branch")
    parser.add_argument('--html', action='store_true',
                        help='produce HTML output')
    parser.add_argument('--symlink-assets', action='store_true',
                        help='symlink the assets directory next to the HTML output file')
    parser.add_argument('-o', metavar='FILENAME', dest='output_file',
                        help='write the output to a file (default: stdout)')
    parser.add_argument('--http-cache', default='.httpcache.sqlite', metavar='DBNAME',
                        help='cache HTTP responses on disk in an sqlite database (default: %(default)s)')
    parser.add_argument('--no-http-cache', action='store_false', dest='http_cache',
                        help='disable HTTP disk caching (not recommended)')
    parser.add_argument('--cache-duration', default='30m', type=to_seconds,
                        help='how long to cache HTTP requests (default: %(default)s)')
    parser.add_argument('--fetch', '--update', action='store_true',
                        help='run git fetch in each project')
    parser.add_argument('--pull', action='store_true',
                        help='run git pull in each project')
    args = parser.parse_args()

    log.addHandler(logging.StreamHandler())
    log.setLevel(logging.DEBUG if args.verbose >= 3 else
                 logging.INFO if args.verbose >= 1 else
                 logging.ERROR)

    if args.http_cache:
        log.debug('caching HTTP requests for %s', args.cache_duration)
        requests_cache.install_cache(
            args.http_cache,
            backend='sqlite',
            expire_after=args.cache_duration,
            allowable_codes=(200, 302),
        )
        cache: Cache = SQLiteCache(args.http_cache)
    else:
        cache = MemoryCache()

    session = requests.Session()
    session.headers['User-Agent'] = f'project-summary/{__version__}'

    config = Configuration()
    if args.fetch is not None:
        config.fetch = args.fetch
    if args.pull is not None:
        config.pull = args.pull
    if args.skip_branches is not None:
        config.skip_branches = args.skip_branches
    projects = get_projects(config, session, cache)
    if args.html:
        try:
            if args.verbose:
                print_report(projects, args.verbose - 1, file=sys.stderr)
            print_html_report(projects, config, args.output_file)
            if args.symlink_assets:
                symlink_assets(args.output_file)
        except (httpx.HTTPError, requests.HTTPError) as e:
            sys.exit(f"HTTP error: {e}")
        except requests.ConnectionError as e:
            sys.exit(f"Network error: {e}")
        except GitHubError as e:
            sys.exit(f"GitHub error: {e}")
        except Exception:
            # if I let CPython print the exception, it'll ignore all of
            # my extra information stuffed into linecache :/
            traceback.print_exc()
            sys.exit(1)
    else:
        if args.output_file:
            print("warning: --output-file ignored in non-HTML mode", file=sys.stderr)
        print_report(projects, args.verbose)


def print_report(projects: list[Project], verbose: int, file: TextIO | None = None) -> None:
    # https://github.com/python/mypy/issues/8928
    print_ = functools.partial(print, file=file if file is not None else sys.stdout)
    for project in projects:
        project.precompute('name pending_commits last_tag last_tag_date'.split())
        if verbose >= 1:
            project.precompute('compare_url python_versions'.split())
        if verbose >= 2:
            project.precompute('working_tree'.split())
        print_("{name:24} {commits:4} commits since {release:6} ({date})".format(
            name=project.name, commits=len(project.pending_commits),
            release=project.last_tag, date=nice_date(project.last_tag_date)))
        if verbose >= 1:
            print_("  {}".format(project.compare_url))
            if verbose >= 2:
                print_("  {}".format(project.working_tree))
            print_("  Python versions: {}".format(", ".join(project.python_versions)))
            print_("  Issues: {} new, {} total".format(project.unlabeled_open_issues_count, project.open_issues_count))
            print_("  PRs: {} new, {} total".format(project.unlabeled_open_issues_count, project.open_pulls_count))
            print_("")


def print_html_report(projects: list[Project], config: Configuration, filename: str | None = None) -> None:
    # I want atomicity: don't destroy old .html file if an exception happens
    # during rendering.
    html = template.render_unicode(
        projects=projects,
        config=config,
        report_pages=get_report_pages(config),
    )
    if filename and filename != '-':
        with open(filename, 'w') as f:
            f.write(html)
    else:
        print(html)


def symlink_assets(filename: str | None = None) -> None:
    if filename and filename != '-':
        symlink = pathlib.Path(filename).with_name('assets')
        if not symlink.exists():
            target = pathlib.Path(__file__).with_name('assets')
            symlink.symlink_to(target)


if __name__ == '__main__':
    main()
